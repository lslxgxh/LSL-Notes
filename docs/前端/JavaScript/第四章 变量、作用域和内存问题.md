## 第四章 变量、作用域和内存问题

### 4.1 基本类型和引用类型

**基本类型值**：简单的数据段；按值访问，可以操作保存在变量中的实际值；

**引用类型值**：可能由多个值组成的对象；当复制保存着对象的某个变量时，操作的是变量的引用；但在为对象添加属性时，操作的是实际的对象；

#### 4.1.1动态的属性

只能给引用类型的值动态的添加新属性，而不能为基本数据类型添加属性；

#### 4.1.2 复制变量值

##### 1.基本数据类型

从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上；基本数据类型值在内存中占据固定大小的空间，因此被保存在栈内存中。

**复制前的变量对象**：

|      |      |
| :--: | :--: |
|      |      |
| num1 |  5   |

**复制后的变量对象**：

|      |      |
| :--: | :--: |
| num2 |  5   |
| num1 |  5   |

##### 2.引用数据类型

当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份到新变量分配的空间中；但是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象，复制操作结束后，两个变量实际上将引用同一个对象，因此改变其中一个变量就会影响另一个变量；引用类型的值是对象，保存在堆内存中。

![1557991786731](C:\Users\L\AppData\Local\Temp\1557991786731.png)

#### 4.1.3 传递参数

**向参数传毒基本类型值：**被传递的值会复制给一个局部变量；

**向参数传递引用数据类型值：**会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量得到变化会反映在函数的外部；（当在函数内部重写obj时，这个变量引用的就是一个局部对象了，而这个局部对象会在函数执行完毕后立即被销毁）

#### 4.1.4 检测类型

**typeof**：是确定一个变量时字符串、数值、布尔值、还是undefined的最佳工具q，如果变量的值时null，则会返回object；（基本数据类型）；使用typeof检测函数时。会返回“function”，检测正则表达式——“function”；在内部实现[[call]]方法的对象都应该返回function；

**instanceof**：主要用于检测引用数据类型；所有引用类型的值都是object的实例，因此在检测一个引用类型和object构造函数时，instanceof操作符总会返回true；若检测基本数据类型，则会返回false；

### 4.2 执行环境及作用域

执行环境定义了变量或函数有权访问其他数据，每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。

全局执行环境是最外围的一个执行环境。全局执行环境被认为是window对象。

某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量何函数定义也随之销毁（全局执行环境直到应用程序退出时才会被销毁）；

当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。

当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途时保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终时当前执行的代码所在的环境的变量对象，如果这个环境是函数，则将其活动对象作为变量对象。活动对象在最开始是只包含一个变量，即argument对象（这个对象在全局环境中时不存在的）

在局部作用域中定义的变量可以在局部环境中与全局变量互换使用。

内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。

#### 4.2.1 延长作用域链

在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除；

**try-catch**:catch语句会创建一个新的变量对象，

**with**： 会将指定的对象添加到作用域链中。with中首先查找的是相关对象的属性，如果没有，才会改变变量的值。

#### 4.2.2 没有块级作用域

if 语句中的变量声明会将变量添加到当前的执行环境中。

由for语句创建的变量i 即使在for 循环执行结束后，也会存在在循环外部的执行环境中；

##### 1.声明变量

使用var声明的变量会自动被添加到最接近的环境中；如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境中。

##### 2.查询标识符

搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。在这个搜索过程中，如果存在一个局部变量的定义，则搜索会自动停止，不再进入另一个变量对象。换句话说，如果局部环境中存在着同名标识符，就不会使用位于夫环境中的标识符。

### 4.3 垃圾收集

#### 4.3.1 标记清除

当变量进入环境时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，而当变量离开环境时，则将其标记为“离开环境”。最后标记还存在的变量将视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了，最后垃圾收集器会完成内存清除工作。

#### 4.3.2 引用计数

当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用此时就是1；如果同一个值又被赋给另一个变量，则该值的引用次数加1，相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用此时变成0，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。

当代码中存在循环引现象时，引用计数就会导致问题。

#### 4.3.3 管理内存

内存限制问题不仅会影响给变量分配内存，同时还会调用栈以及在一个线程中能够同时执行的语句数量。

一旦数据不再有用，最好通过将其值设置为null来释放其引用，这个方法叫做解除引用，这一做法适用于大多数全局变量和全局对象的属性，局部变量会在他们离开执行环境时自动被解除引用。

