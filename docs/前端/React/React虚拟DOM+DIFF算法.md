# React虚拟DOM

## first：

1. state数据
2. JSX模板
3. 数据+模板结合，生成真实的DOM，显示
4. state 发生改变
5. 数据+模板结合，生成真实的DOM，替换原始的DOM

##### 缺陷：

1. 第一次生成了一个完整的DOM片段
2. 第二次生成了一个完整的DOM片段
3. 第二次的替换了第一次的，非常耗性能



## second：

1. state数据
2. JSX模板
3. 数据＋模板，生成真实DOM，显示
4. state发生改变
5. 数据+模板，生成真实DOM，并不直接替换原始的DOM，
6. 新的DOM与原始的DOM进行比较，找出差异
7. 找出input框发生了变化
8. 只用新的DOM中的input元素替换掉老的Input元素

##### 缺点：

性能的提升并不明显

依旧生成了两个真实DOM，而且在进行比较的时候依然会损耗性能



## third：

1. state数据
2. JSX模板
3. 数据＋模板，生成虚拟DOM（虚拟DOM就是一个JS对象，用它来描述真实DOM）

['div',{id:'abc'},{'span',{},'hello'}]

4. 利用虚拟的DOM生成真实DOM，显示

<div id='abc'><span>hello</span></div>

5. state发生变化
6. 数据+模板，生成新的虚拟DOM（极大的提升了性能）

['div',{id:'abc'},{'span',{},'bye'}]

7. 比较原始虚拟DOM与新的虚拟DOM的区别，找到区别为span中的内容（极大的提升了性能）
8. 直接操作DOM，改变span中的内容

**JSX—（React.createElement）—> JS对象——>真实的DOM**

##### 优点

减少了对真实DOM的创建和DOM的对比

虚拟DOM本质上就是一个JS对象，所以JS对象之间的比较不怎么消耗性能，但是比较真实的DOM会很消耗性能。

使得跨端应用得以实现。React Native(虚拟DOM可以在浏览器和原生应用里头都可以被识别，都可以转换成适合各自的组间或DOM)



# DIFF算法

**——（比较虚拟DOM之间的差异）**

**setState（）——异步**

**同级比对（同层比对）：**

一层一层的比对，如果第一层的比对就不同，那么就不会再进行剩下层级的比对，而会直接将剩余的层级全都重新渲染。

**Key值：**

在做虚拟DOM循环的时候，会节约很多性能，也会变得简单。

但前提是旧的虚拟DOM与新的虚拟DOM树上的相同节点Key值相同，所以不推荐用index作为key值就是因为这样做新旧DOM树上一些相同的节点的key值不同，导致key值不稳定，就无法起到节约性能的目的。

可以利用item作为key值，使用稳定的内容作为key值。